@* Binary to T81Z Compressor *@
This program converts binary input (from a file or stdin) into a ternary sequence (trits: -1, 0, +1), compresses it using RLE or Huffman coding, and outputs a T81Z file with metadata and CRC32 checksum. It supports command-line options for input/output files, compression method, and bit-to-trit chunk size.
@c

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <math.h>
#include <time.h>
#include <openssl/sha.h> // For CRC32 (placeholder)
#define MAX_DATA_SIZE 1024
#define TRIT_VALUES 3
#define MAX_CODE_LENGTH 8
#define DEFAULT_CHUNK_SIZE 5 // Bits per 3-trit group
typedef int8_t Trit; // -1, 0, +1
typedef struct {
    Trit data[MAX_DATA_SIZE];
    int length;
} T81Data;
typedef struct {
    char magic[4];      // 'T81Z'
    uint8_t version;    // Format version (1)
    uint16_t original_length;
    char method[4];     // 'RLE' or 'HUF'
    uint32_t crc32;     // Checksum of original trit data
} T81ZHeader;
typedef struct {
    uint8_t code[MAX_CODE_LENGTH];
    int length;
} HuffmanCode;
typedef struct {
    HuffmanCode codes[TRIT_VALUES];
} HuffmanTable;
@<Global Variables@>
@<Binary to Ternary Conversion@>
@<Compression Routines@>
@<Entropy Analysis@>
@<File Output Utilities@>
@<Huffman Utilities@>
@<Command-Line Parsing@>
int main(int argc, char* argv[]) {
    char* input_file = NULL;
    char* output_file = "output.t81z";
    char* method = "HUF";
    int chunk_size = DEFAULT_CHUNK_SIZE;

@<Parse Command-Line Arguments@>

// Read binary input
uint8_t binary_buffer[MAX_DATA_SIZE];
int binary_length = 0;
FILE* input = (input_file && strcmp(input_file, "-") != 0) ? fopen(input_file, "rb") : stdin;
if (!input) {
    fprintf(stderr, "Error: Could not open input %s\n", input_file ? input_file : "stdin");
    return 1;
}
binary_length = fread(binary_buffer, 1, MAX_DATA_SIZE, input);
if (input != stdin) fclose(input);

// Convert to ternary
T81Data trit_data;
clock_t start = clock();
binary_to_trits(binary_buffer, binary_length, &trit_data, chunk_size);

// Compress
uint8_t compressed_buffer[MAX_DATA_SIZE];
int compressed_length;
HuffmanTable huff_table;
if (strcmp(method, "RLE") == 0) {
    rle_compress(&trit_data, compressed_buffer, &compressed_length);
} else if (strcmp(method, "HUF") == 0) {
    build_huffman_table(&trit_data, &huff_table);
    huffman_compress(&trit_data, compressed_buffer, &compressed_length, &huff_table);
} else {
    fprintf(stderr, "Unknown compression method: %s\n", method);
    return 1;
}

// Write output
write_compressed_file(output_file, &trit_data, compressed_buffer, compressed_length, method);

// Benchmark
double time_taken = (double)(clock() - start) / CLOCKS_PER_SEC;
double ratio = (double)compressed_length / (trit_data.length * sizeof(Trit));
double entropy = entropy_score(&trit_data);

printf("Binary to T81Z Conversion and Compression:\n");
printf("  Input binary size: %d bytes\n", binary_length);
printf("  Ternary size: %d trits (%d bytes)\n", trit_data.length, trit_data.length * (int)sizeof(Trit));
printf("  Compressed size: %d bytes\n", compressed_length);
printf("  Compression ratio: %.2f (compressed/ternary)\n", ratio);
printf("  Entropy: %.2f bits/trit\n", entropy);
printf("  Time: %.4f seconds\n", time_taken);
printf("  Output file: %s\n", output_file);

return 0;

}
@*1 Global Variables
@<Global Variables@>=
static const uint8_t bit_to_trit_map[32][3] = {
    {-1, -1, -1}, {-1, -1, 0}, {-1, -1, 1}, {-1, 0, -1}, {-1, 0, 0}, {-1, 0, 1}, {-1, 1, -1}, {-1, 1, 0},
    {-1, 1, 1}, {0, -1, -1}, {0, -1, 0}, {0, -1, 1}, {0, 0, -1}, {0, 0, 0}, {0, 0, 1}, {0, 1, -1},
    {0, 1, 0}, {0, 1, 1}, {1, -1, -1}, {1, -1, 0}, {1, -1, 1}, {1, 0, -1}, {1, 0, 0}, {1, 0, 1},
    {1, 1, -1}, {1, 1, 0}, {1, 1, 1}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}
};
@*1 Binary to Ternary Conversion
@<Binary to Ternary Conversion@>=
void binary_to_trits(const uint8_t* binary, int binary_length, T81Data* trits, int chunk_size) {
    if (chunk_size != 5) {
        fprintf(stderr, "Only chunk_size=5 is supported\n");
        exit(1);
    }
    trits->length = 0;
    int bit_pos = 0;
    while (bit_pos < binary_length * 8 && trits->length + 3 <= MAX_DATA_SIZE) {
        // Extract 5 bits
        int value = 0;
        for (int i = 0; i < 5 && bit_pos < binary_length * 8; ++i) {
            value = (value << 1) | ((binary[bit_pos / 8] >> (7 - (bit_pos % 8))) & 1);
            bit_pos++;
        }
        if (value < 27) { // 27 valid trit combinations
            trits->data[trits->length++] = bit_to_trit_map[value][0];
            trits->data[trits->length++] = bit_to_trit_map[value][1];
            trits->data[trits->length++] = bit_to_trit_map[value][2];
        }
    }
    // Handle remaining bits (pad with 0s)
    if (bit_pos < binary_length * 8 && trits->length < MAX_DATA_SIZE) {
        int remaining = binary_length * 8 - bit_pos;
        for (int i = 0; i < remaining && trits->length < MAX_DATA_SIZE; ++i) {
            trits->data[trits->length++] = 0;
        }
    }
}
@*1 Compression Routines
@<Compression Routines@>=
void rle_compress(const T81Data* data, uint8_t* buffer, int* out_length) {
    *out_length = 0;
    for (int i = 0; i < data->length; ) {
        Trit t = data->data[i];
        int run = 1;
        while (i + run < data->length && data->data[i + run] == t && run < 255) {
            run++;
        }
        if (*out_length + 2 > MAX_DATA_SIZE) {
            fprintf(stderr, "Buffer overflow in RLE compression\n");
            exit(1);
        }
        buffer[(*out_length)++] = (uint8_t)(t + 1);
        buffer[(*out_length)++] = (uint8_t)run;
        i += run;
    }
}
@*1 Entropy Analysis
@<Entropy Analysis@>=
double entropy_score(const T81Data* data) {
    if (data->length <= 0) return 0.0;
    int counts[TRIT_VALUES] = {0};
    for (int i = 0; i < data->length; ++i) {
        if (data->data[i] < -1 || data->data[i] > 1) {
            fprintf(stderr, "Invalid trit: %d\n", data->data[i]);
            exit(1);
        }
        counts[data->data[i] + 1]++;
    }
    double score = 0.0;
    for (int i = 0; i < TRIT_VALUES; ++i) {
        if (counts[i] > 0) {
            double p = counts[i] / (double)data->length;
            score -= p * log2(p);
        }
    }
    return score;
}
@*1 Huffman Utilities
@<Huffman Utilities@>=
void build_huffman_table(const T81Data* data, HuffmanTable* table) {
    // Fixed codes: -1: 10, 0: 0, +1: 11
    table->codes[0].length = 2; // -1
    table->codes[0].code[0] = 1; table->codes[0].code[1] = 0;
    table->codes[1].length = 1; // 0
    table->codes[1].code[0] = 0;
    table->codes[2].length = 2; // +1
    table->codes[2].code[0] = 1; table->codes[2].code[1] = 1;
}
void huffman_compress(const T81Data* data, uint8_t* buffer, int* out_length, HuffmanTable* table) {
    int bit_pos = 0;
    *out_length = 0;
    memset(buffer, 0, MAX_DATA_SIZE);
    for (int i = 0; i < data->length; ++i) {
        int idx = data->data[i] + 1;
        for (int j = 0; j < table->codes[idx].length; ++j) {
            if (bit_pos >= MAX_DATA_SIZE * 8) {
                fprintf(stderr, "Buffer overflow in Huffman compression\n");
                exit(1);
            }
            if (table->codes[idx].code[j]) {
                buffer[bit_pos / 8] |= (1 << (7 - (bit_pos % 8)));
            }
            bit_pos++;
        }
    }
    *out_length = (bit_pos + 7) / 8;
}
@*1 File Output Utilities
@<File Output Utilities@>=
uint32_t compute_crc32(const T81Data* data) {
    unsigned char* bytes = (unsigned char*)data->data;
    uint32_t crc = 0;
    SHA256(bytes, data->length * sizeof(Trit), (unsigned char*)&crc); // Placeholder
    return crc;
}
void write_compressed_file(const char* filename, const T81Data* data, const uint8_t* buffer, int buffer_length, const char* method) {
    FILE* f = fopen(filename, "wb");
    if (!f) {
        fprintf(stderr, "Error: Could not open file for writing: %s\n", filename);
        exit(1);
    }
    T81ZHeader header = {
        .magic = {'T', '8', '1', 'Z'},
        .version = 1,
        .original_length = (uint16_t)data->length,
        .crc32 = compute_crc32(data)
    };
    strncpy(header.method, method, 4);
    fwrite(&header, sizeof(T81ZHeader), 1, f);
    fwrite(buffer, 1, buffer_length, f);
    fclose(f);
}
@*1 Command-Line Parsing
@<Command-Line Parsing@>=
void parse_args(int argc, char* argv[], char** input_file, char** output_file, char** method, int* chunk_size) {
    for (int i = 1; i < argc; ++i) {
        if (strcmp(argv[i], "--input") == 0 && i + 1 < argc) {
            *input_file = argv[++i];
        } else if (strcmp(argv[i], "--output") == 0 && i + 1 < argc) {
            *output_file = argv[++i];
        } else if (strcmp(argv[i], "--method") == 0 && i + 1 < argc) {
            *method = argv[++i];
            if (strcmp(*method, "RLE") != 0 && strcmp(*method, "HUF") != 0) {
                fprintf(stderr, "Invalid method: %s\n", *method);
                exit(1);
            }
        } else if (strcmp(argv[i], "--chunk-size") == 0 && i + 1 < argc) {
            *chunk_size = atoi(argv[++i]);
            if (*chunk_size != 5) {
                fprintf(stderr, "Only chunk-size=5 is supported\n");
                exit(1);
            }
        } else {
            fprintf(stderr, "Unknown argument: %s\n", argv[i]);
            exit(1);
        }
    }
}
@<Parse Command-Line Arguments@>=
parse_args(argc, argv, &input_file, &output_file, &method, &chunk_size);
